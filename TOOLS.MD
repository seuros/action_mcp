# ActionMCP Tools Guide

## 🚀 START HERE: Use the Generator!

**Don't write tools from scratch!** Use the Rails generator:

```bash
# Simplest tool - just give it a name
bin/rails generate action_mcp:tool AddNumbers

# Tool that only reads data
bin/rails generate action_mcp:tool GetUserInfo --read-only

# Tool that calls external APIs
bin/rails generate action_mcp:tool FetchWeather --read-only --open-world

# Tool that changes data
bin/rails generate action_mcp:tool CreateOrder --destructive

# Tool with custom properties
bin/rails generate action_mcp:tool SendEmail to:string subject:string body:string --destructive --open-world
```

## Generator Options Explained

- `--read-only` - Tool only reads, doesn't change anything
- `--destructive` - Tool can delete or modify data
- `--idempotent` - Running twice with same input = same result
- `--open-world` - Tool talks to external systems (APIs, files, etc.)
- `--title "Pretty Name"` - Human-friendly name for UI display

## What the Generator Creates

Running `bin/rails generate action_mcp:tool CalculateSum` creates:

**File:** `app/mcp/tools/calculate_sum_tool.rb`

```ruby
# frozen_string_literal: true

class CalculateSumTool < ApplicationMCPTool
  tool_name "calculate_sum"
  description "Calculate sum"

  property :input, type: "string", description: "Input", required: true

  def perform
    render(text: "Processing input")

    # Optional outputs:
    # render(audio: "<base64_data>", mime_type: "audio/mpeg")
    # render(image: "<base64_data>", mime_type: "image/png")
    # render(resource: "file://path", mime_type: "application/json", text: "{}")
    # render(resource: "file://path", mime_type: "application/octet-stream", blob: "<base64_data>")
  rescue => e
    report_error("Error: #{e.message}")
  end
end
```

## Three Complete Examples

### 1. Calculator Tool (Simplest)

**Generate:**
```bash
bin/rails generate action_mcp:tool AddNumbers a:number b:number
```

**Modify the `perform` method:**
```ruby
def perform
  result = a + b
  render(text: "#{a} + #{b} = #{result}")
end
```

That's it! The tool now adds two numbers.

### 2. Database Reader Tool

**Generate:**
```bash
bin/rails generate action_mcp:tool GetUserCount --read-only
```

**Modify the `perform` method:**
```ruby
def perform
  count = User.count
  render(text: "Total users: #{count}")
end
```

### 3. Weather API Tool

**Generate:**
```bash
bin/rails generate action_mcp:tool GetWeather city:string --read-only --open-world
```

**Modify the `perform` method:**
```ruby
def perform
  # Your API call here
  weather_data = fetch_weather_for(city)
  render(text: "Weather in #{city}: #{weather_data[:temp]}°C, #{weather_data[:description]}")
rescue => e
  report_error("Could not fetch weather: #{e.message}")
end

private

def fetch_weather_for(city)
  # Your HTTP request logic here
  { temp: 22, description: "Sunny" }
end
```

## The Core Pattern

Every tool follows this pattern:

```ruby
class YourToolNameTool < ApplicationMCPTool
  tool_name "your_tool_name"        # Required: unique identifier
  description "What this tool does"  # Required: explain the purpose
  
  # Define inputs (properties become method names!)
  property :user_id, type: "string", description: "The user's ID", required: true
  property :limit, type: "number", description: "Max results", required: false
  
  def perform
    # Your logic here
    # Access properties as methods: user_id, limit
    
    # Return results using render
    render(text: "Your result here")
  end
end
```

## Property Types

- `"string"` - Text input
- `"number"` - Numeric input (integer or float)
- `"boolean"` - true/false
- `"array"` - List of items
- `"object"` - ⚠️ **Limited support** - See Input Schema Limitations below

## ⚠️ Input Schema Limitations

**Important:** The MCP specification currently only supports **flat, single-level** input schemas. While JSON Schema technically allows nested objects, the MCP spec intentionally keeps input parameters at one level.

### Why Flat Schemas?

1. **LLM Performance** - Language models work better with flat parameter lists
2. **Spec Compliance** - Prevents drift from official MCP specification  
3. **SDK Compatibility** - Strict validation in newer SDKs will reject nested structures

### Complex Data Workaround

For complex configuration or nested data, use the **JSON string pattern**:

```ruby
class ConfigUpdateTool < ApplicationMCPTool
  tool_name "config_update"
  description "Update multiple configuration properties"
  
  # Use JSON string instead of nested object
  property :config_json, type: "string", description: "JSON string of configuration object"
  
  def perform
    # Parse the JSON string to get your complex object
    config = JSON.parse(config_json)
    
    # Now you can work with nested data
    config.each do |key, value|
      update_config(key, value)
    end
    
    render(text: "Updated #{config.keys.length} configuration properties")
  end
end
```

**Example tool call:**
```json
{
  "config_json": "{\"database_host\": \"localhost\", \"cache_ttl\": 3600, \"debug_mode\": true}"
}
```

### Spec Compliance Notes

- **Use `"number"` not `"float"`** - `"float"` is not valid JSON Schema
- **Test with MCP Inspector** - Frontier models may "fix" invalid schemas, but strict SDKs will reject them
- **Avoid `type: "object"`** for input properties unless you're implementing experimental features

## Additional Properties (Dynamic Inputs)

Tools can accept extra parameters beyond those explicitly defined using `additional_properties`:

```ruby
class FlexibleApiTool < ApplicationMCPTool
  tool_name "flexible_api"
  description "API caller that accepts dynamic parameters"
  
  # Define core properties
  property :endpoint, type: "string", description: "API endpoint", required: true
  property :method, type: "string", description: "HTTP method", default: "GET"
  
  # Allow any additional properties
  additional_properties true
  
  def perform
    # Access defined properties normally
    url = endpoint
    http_method = method
    
    # Access additional properties through special method
    extra_params = additional_params
    
    render(text: "Calling #{url} with method #{http_method}")
    extra_params.each do |key, value|
      render(text: "Extra param #{key}: #{value}")
    end
  end
end
```

**Additional Properties Options:**

```ruby
# Allow any additional properties of any type
additional_properties true

# Explicitly disallow additional properties 
additional_properties false

# Allow additional properties but restrict to strings
additional_properties({"type" => "string"})

# Allow additional properties with more complex schemas
additional_properties({
  "type" => "object",
  "properties" => {
    "timeout" => {"type" => "number"}
  }
})
```

**Use Cases for Additional Properties:**

1. **API Proxy Tools** - Forward arbitrary parameters to external APIs
2. **Configuration Tools** - Accept flexible configuration options
3. **Open World Tools** - Handle unpredictable input structures
4. **Dynamic Data Processing** - Work with varying data schemas

**Example Usage:**

```json
// Tool call with additional properties
{
  "endpoint": "/api/users",
  "method": "POST",
  "auth_token": "secret123",    // Additional property
  "timeout": 5000,             // Additional property  
  "debug": true                // Additional property
}
```

## Output Schema (Structured Responses)

Tools can define structured output schemas to provide predictable, validated responses that LLMs can reliably parse and use:

```ruby
class WeatherTool < ApplicationMCPTool
  tool_name "weather"
  description "Get weather with structured output"
  
  property :location, type: "string", required: true
  
  # Define the structure of your tool's output
  output_schema do
    boolean :success, required: true
    string :message
    
    object :current do
      number :temperature, required: true
      string :condition, required: true
      number :humidity, minimum: 0, maximum: 100
    end
    
    array :forecast do
      object do
        string :date, format: "date", required: true
        number :high, required: true
        number :low, required: true
      end
    end
  end
  
  def perform
    # Return structured data that matches your schema
    render structured: {
      success: true,
      message: "Weather retrieved for #{location}",
      current: { temperature: 22.5, condition: "Sunny", humidity: 65 },
      forecast: [
        { date: "2025-01-01", high: 25, low: 18 }
      ]
    }
  end
end
```

### Output Schema DSL Methods

- `string :name` - Text property
- `number :price` - Numeric property  
- `boolean :active` - True/false property
- `object :data do...end` - Nested object with properties
- `array :items do...end` - Array with item schema
- `additional_properties true` - Allow extra properties

### Schema Constraints

- `required: true` - Property must be present
- `minimum: 0, maximum: 100` - Numeric bounds
- `format: "date"` - String format (date, date-time, uri, email)
- `enum: ["option1", "option2"]` - Allowed values
- `default: "value"` - Default value

### Real Examples

**Complex nested schema:** See `test/dummy/app/mcp/tools/weather_tool.rb`
- Shows nested objects, arrays, timestamps
- Demonstrates optional vs required fields
- Includes metadata and forecast arrays

**Configuration schema:** See `test/dummy/app/mcp/tools/config_update_tool.rb`  
- Shows flat and nested object patterns
- Array of simple string warnings
- Success/message response pattern

### When to Use Output Schemas

✅ **Use output schemas when:**
- LLMs need to parse your data programmatically  
- Building multi-step workflows with tool chaining
- Providing structured data (JSON, database records)
- Creating consistent API-like responses

❌ **Skip output schemas for:**
- Simple text responses or status messages
- Creative content generation
- Progress updates during execution
- Human-readable summaries

**Key benefit:** LLMs can reliably extract specific data from your tool's response instead of parsing free-form text.

### Input vs Output Schema Differences

**Important distinction:**

| Feature | Input Schema | Output Schema |
|---------|--------------|---------------|
| **Nesting Level** | Flat only (single level) | Unlimited nesting depth |
| **Object Types** | Discouraged/Limited | Fully supported |
| **Spec Status** | Strictly defined | More flexible |
| **Why Different?** | LLMs handle flat params better | LLMs need structured data parsing |

**Input schemas** must be flat because:
- LLMs process simple parameter lists more reliably
- Prevents infinite nesting complexity (HomeAssistant configs going 10 levels deep)
- Maintains MCP specification compliance

**Output schemas** can be deeply nested because:
- LLMs need to parse complex returned data structures
- Response parsing is different from parameter understanding
- Tools often return rich, structured data (APIs, databases, etc.)

## Render Options

You can call `render` multiple times to show progress:

```ruby
def perform
  render(text: "Starting process...")
  
  # Do some work
  result = process_data
  
  render(text: "Processing complete!")
  render(text: "Result: #{result}")
  
  # You can also render:
  render(image: base64_image_data, mime_type: "image/png")
  render(audio: base64_audio_data, mime_type: "audio/mpeg")
  
  # For errors, use the helper method:
  report_error("Something went wrong")
end
```

## Adding Validation

Use standard Rails validations:

```ruby
class CreateUserTool < ApplicationMCPTool
  property :email, type: "string", description: "User email", required: true
  property :age, type: "number", description: "User age", required: true
  
  # Rails validations work!
  validates :email, format: { with: URI::MailTo::EMAIL_REGEXP }
  validates :age, numericality: { greater_than: 0, less_than: 150 }
  
  def perform
    # Validation runs automatically before perform
    User.create!(email: email, age: age)
    render(text: "User created successfully")
  end
end
```

## Consent Management for Sensitive Tools

Some tools perform sensitive operations and require explicit user consent:

```ruby
class DeleteUserTool < ApplicationMCPTool
  tool_name "delete_user"
  description "Delete a user account"
  
  # Require explicit consent before execution
  requires_consent!
  
  property :user_id, type: "string", description: "User ID to delete", required: true
  
  def perform
    # This code only runs after user grants consent
    user = User.find(user_id)
    user.destroy!
    render(text: "User #{user.name} has been deleted")
  end
end
```

**When to use consent:**
- File system operations
- Database modifications
- External API calls that change data
- Any destructive operations

**Consent Flow:**
1. Tool called without consent → Returns error -32002
2. Client grants consent for specific tool
3. Tool executes normally for that session

```ruby
# Managing consent programmatically
session.consent_granted_for?("delete_user")  # Check consent
session.grant_consent("delete_user")         # Grant consent
session.revoke_consent("delete_user")        # Revoke consent
```

## Testing Your Tool

### 1. Check if your tool is registered:
```bash
bundle exec rails action_mcp:list_tools
```

### 2. Test with MCP Inspector:
```bash
# Start your MCP server
bundle exec rails s -c mcp.ru -p 62770

# In another terminal, run the inspector
npx @modelcontextprotocol/inspector --url http://localhost:62770
```

**⚠️ Important Testing Notes:**

- **Always test with MCP Inspector** for true spec compliance validation
- **Don't rely solely on Claude Code testing** - Frontier models will "fix" broken schemas and missing fields, giving false confidence
- **SDK strictness is increasing** - What works today with "vibed" clients may break tomorrow with strict validation
- **Historical example:** `"float"` and `"array_float"` types worked until the JavaScript SDK was patched to enforce proper JSON Schema types

### 3. Write a test:
```ruby
# test/mcp/tools/your_tool_test.rb
require "test_helper"
require "action_mcp/test_helper"

class YourToolTest < ActiveSupport::TestCase
  include ActionMCP::TestHelper
  
  test "does the thing" do
    assert_tool_findable("your_tool")
    result = execute_tool("your_tool", input: "test")
    assert_tool_output(result, "Expected output")
  end
  
  test "consent required tool" do
    # Tool should require consent first
    assert_raises ActionMCP::ConsentRequiredError do
      execute_tool("delete_user", user_id: "123")
    end
    
    # Grant consent and try again
    session.grant_consent("delete_user")
    result = execute_tool("delete_user", user_id: "123")
    assert_tool_output(result, "User deleted")
  end
end
```

## Quick Checklist

✅ Used the generator? `bin/rails generate action_mcp:tool ToolName`  
✅ Tool inherits from `ApplicationMCPTool`?  
✅ Has unique `tool_name`?  
✅ Has clear `description`?  
✅ Properties match what you use in `perform`?  
✅ Using `render` to return results?  
✅ Tool shows up in `rails action_mcp:list_tools`?  

## Error Handling and Clear Messages

Tools should return clear error messages to the LLM using the `render` method:

```ruby
class FileReaderTool < ApplicationMCPTool
  def perform
    unless File.exist?(file_path)
      report_error("File not found: #{file_path}")
      return
    end
    
    begin
      content = File.read(file_path)
      render(text: "File contents: #{content}")
    rescue => e
      report_error("Could not read file: #{e.message}")
    end
  end
end
```

**Error Types:**
- **Validation errors** - Automatic from property validation
- **Consent errors** - Code -32002 when consent required
- **Tool errors** - Use `report_error("Clear message for LLM")`
- **Success responses** - Use `render(text: "Success message")`

## Common Issues

**Tool not showing up in list?**
- Make sure it inherits from `ApplicationMCPTool`
- Check the file is in `app/mcp/tools/`
- Restart your server
- Verify with `bundle exec rails action_mcp:list_tools`

**Getting "undefined method" errors?**
- Property names become method names: `property :user_id` → use `user_id` in perform
- Check spelling matches exactly
- Properties are automatically validated and accessible

**Validation errors?**
- Required properties must be provided
- Check your validates rules
- Error will show which validation failed
- Use Rails validations for complex rules

**Consent errors?**
- Tool returns error -32002 when consent required
- Grant consent using `session.grant_consent(tool_name)`
- Consent is session-scoped and persists until revoked

**Session not found?**
- Ensure session exists in session store
- Check session ID is properly passed in headers
- Use fixtures in tests for consistent sessions

## Advanced Features

### Multiple Output Types
```ruby
def perform
  # Text output
  render(text: "Processing started...")
  
  # Image output
  chart_data = generate_chart
  render(image: chart_data, mime_type: "image/png")
  
  # Audio output
  audio_data = text_to_speech("Processing complete")
  render(audio: audio_data, mime_type: "audio/mpeg")
  
  # File resource
  render(resource: "file://output.json", 
         mime_type: "application/json",
         text: results.to_json)
end
```

### Authentication Context
```ruby
def perform
  # Access authenticated user
  if current_user
    render(text: "Hello, #{current_user.name}!")
  else
    render(text: "Hello, anonymous user!")
  end
  
  # Access other gateway identifiers
  if current_organization
    render(text: "Organization: #{current_organization.name}")
  end
end
```

### Profile-Based Tool Exposure
```ruby
# Only available in specific profiles
# Configure in config/mcp.yml:
# admin_profile:
#   tools:
#     - admin_tool
#     - delete_user
```

## Performance Tips

1. **Use database indexes** for property lookups
2. **Cache expensive operations** within the perform method
3. **Limit output size** for large datasets
4. **Use background jobs** for long-running operations
5. **Stream progress** with multiple render calls

## Security Best Practices

1. **Validate all inputs** using Rails validations
2. **Use consent for sensitive operations**
3. **Never expose secrets** in tool outputs
4. **Implement proper authorization** in perform method
5. **Sanitize user inputs** before database queries
6. **Use parameterized queries** to prevent SQL injection

## Remember

1. **Always use the generator** - It sets up everything correctly
2. **Properties become methods** - `property :name` means you can use `name` in perform
3. **Multiple renders are fine** - Show progress with multiple render calls
4. **Consent protects users** - Use for any destructive operations
5. **Test thoroughly** - Use TestHelper for comprehensive testing
6. **Context matters** - Error messages adapt to HTTP vs direct calls

That's it! You now know how to create powerful, secure MCP tools. Start with the generator and build from there.